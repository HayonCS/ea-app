/**
 * Hexagonal architecture inspired dependency injection
 *
 * This module provides a type-safe dependency injection mechanism for
 * typescript. If you've used dependency injection in other languages, this is
 * very similar.
 *
 * One difference is that TypeScript doesn't provide reflection,
 * so we can't use the type as a runtime service lookup key, as in e.g. C# or
 * Java. Instead, this API uses the metaphors from Hexagonal Architecture
 * (https://blog.octo.com/en/hexagonal-architecture-three-principles-and-an-implementation-example/).
 * Namely a `Port` is how you look up a service and an `Adapter` proivides that service.
 *
 * A `Context` is a logical container of services (dependency-injection
 * container) that are configured per-http request, per background job, or per
 * script invocation. Access to the context is threaded throughout the
 * application, such as being the context argument to graphql resolvers.
 *
 * The fundamental API of a Context is a `get` method that accepts `Port`
 * values. A `Port` is a constant that represents a service that something
 * might need. A `Port` is basically a lookup key for a service that encodes
 * the type of that service. For example, you could have a `Port` for a
 * database url, which is a string. Or you might have a `Port` for a database
 * connection, as a `Knex` object. A user could talk to the database by using
 * the return value of `context.get(KnexPort)`.
 *
 * Adapters are functions that take a context and produce a value for some
 * port. Adapters can request other services from the context that's invoking
 * them to fetch dependencies, provided those ports have been defined within
 * the context already.
 *
 * Context classes are generated by the `contextClass` function which takes a
 * set of ports and default adapters that instances of that context class use
 * to instantiate services. These classes are typically not used directly, but
 * used as a base class so that a more refined api can be layered on top of the
 * base functionality. (See `context/index.ts`.) Generally, at a minimum, the
 * subclass will provide a constructor that allows overriding key `Ports` that
 * may vary by environment or context, and possibly APIs to easily access
 * commonly-needed `Port`s.
 *
 * Each instance of the `Context` class has its own set of cached values.
 * Generally, creating a `Context` starts with a blank slate. Each call to
 * `get` lazily instantiates the requested service, as well as any dependency
 * services recursively. All values are cached within that instance and servive
 * as long as it does. Thus `Dataloader`s on any used repositories will retain
 * their cache for the lifetime of the context object.
 *
 * A general rule of thumb is to use one `Context` per HTTP request or
 * background job execution, to avoid accidental sharing of cache between
 * requests for different users. `Context` also provides a `clone` method that
 * provides a new context that inherits any defaults/configuration provided to
 * the parent. `clone` is recommended in situations where you want to limit
 * cache growth in dataloaders during batch operations, or you need to create
 * contexts on a per-job basis, etc. and want to inherit any environment
 * configuration, such as for connecting to a test database
 */
export { Context } from "./context";
export { Port } from "./ports";

import { Context, ContextBaseImpl, ContextClass } from "./context";
import { Port, PortType } from "./ports";
import * as R from "./recipe";
export const Recipe = R;
export type Recipe<TPort extends Port> = R.Recipe<TPort>;

/** Declare a port that returns a value of `Type` and is described by the provided globally-unique human-readable description */
export function port<Type, TIdentifier extends string>(
  id: TIdentifier
): Port<TIdentifier, Type> {
  return {
    key: id,
  } as any;
}

/** Declare a port adapter that produces a value for the provided `port` that depends on the services in the array of `requires` ports.
 * `build` is a function that produces the runtime value for `port`. This function is just a type helper to properly ensure use of dependencies.
 * It actually just returns `build` without doing anything..
 */
export function adapter<
  TPort extends Port,
  TConcreteType extends PortType<TPort>,
  TDependencies extends Port
>(args: {
  port: TPort;
  requires?: [];
  build: R.ProviderFunction<Context, TConcreteType>;
}): () => TConcreteType;

export function adapter<
  TPort extends Port,
  TConcreteType extends PortType<TPort>,
  TDependencies extends Port
>(args: {
  port: TPort;
  requires: TDependencies[];
  build: R.ProviderFunction<Context<TDependencies>, TConcreteType>;
}): R.ProviderFunction<Context<TDependencies>, TConcreteType>;

export function adapter(args: { port: any; requires?: any[]; build: any }) {
  return args.build;
}

/** Generate a `Context` class that provides a set of ports with the provided default adapters. */
export function contextClass<T extends Port>(
  f: R.RecipeBuilderFunction<T>
): ContextClass<T> {
  const classRecipe = R.build(f);

  class Context extends ContextBaseImpl<any> {
    protected classRecipe = classRecipe;
  }
  return Context;
}

/** Create a one-off `Context` instance using the provided ports and adapters. */
export function context<T extends Port>(f: R.RecipeBuilderFunction<T>) {
  return new (contextClass(f))();
}

export const recipe = Recipe.build;
